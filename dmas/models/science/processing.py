from abc import ABC, abstractmethod
from collections import defaultdict
from typing import Dict, List
import pandas as pd
import os

from instrupy.base import Instrument

from execsatm.events import GeophysicalEvent
from execsatm.mission import Mission
from execsatm.objectives import EventDrivenObjective
from execsatm.tasks import EventObservationTask

from dmas.core.messages import *
from dmas.models.science.requests import TaskRequest

class ObservationDataProcessor(ABC):
    """
    # Data Processor
    Processes observation data and provides ev
    """
    def __init__(self, parent_name : str, parent_mission : Mission):
        super().__init__()
    
        self.parent_name = parent_name                          # name of parent agent
        self.parent_mission = parent_mission                    # mission of parent agent when events occur

        self.event_requesters : dict[str, GeophysicalEvent] = dict() # event requesters
        self.known_events : set[GeophysicalEvent] = set()       # events known to me (generated by me or others)
        self.known_event_ids : set[str] = set()                 # ids of events known to me
        self.detected_events : set[GeophysicalEvent] = set()    # events detected by me only

        self.known_reqs : set[TaskRequest] = set()              # requests known to me (generated by me or others)
        self.generated_reqs : set[TaskRequest] = set()          # requests generated by me only

    # @runtime_tracker
    def process_observations(self, 
                             incoming_reqs : List[TaskRequest], 
                             observations : list) -> list:
        
        # unpack incoming requests
        incoming_detected_events = {req.event for req in incoming_reqs 
                                    if req.event is not None}
        incoming_event_requesters = {req.event : req.requester 
                                     for req in incoming_reqs
                                     if req.event is not None}
        
        # update list of known events and requests
        self.known_events.update(incoming_detected_events)
        self.known_reqs.update(incoming_reqs)

        # update list of event requesters
        self.event_requesters.update(incoming_event_requesters)

        # initiate requests generated
        requests : list[TaskRequest] = list()

        # process observations
        for instrument,observation_data in observations:
            for obs in observation_data:
                # process observation
                event : GeophysicalEvent = self.process_observation(instrument, obs)

                # no event in observation; skip
                if event is None: continue

                # event has already been detected; skip
                if event in self.known_events: continue
                if event.id in self.known_event_ids: continue

                # get event objetives from mission
                objectives  : list[EventDrivenObjective] = [objective for objective in self.parent_mission.objectives
                                                            if isinstance(objective, EventDrivenObjective)
                                                            and objective.event_type == event.event_type]

                for objective in objectives:
                    objective : EventDrivenObjective
                    # create task
                    task = EventObservationTask(objective.parameter, event=event, objective=objective)

                    # generate task request 
                    task_request = TaskRequest(task,
                                            requester = self.parent_name,
                                            mission_name = self.parent_mission.name,
                                            t_req = obs['t_end'])
                    
                    # update list of generated requests 
                    self.known_reqs.add(task_request)
                    self.generated_reqs.add(task_request)
                    requests.append(task_request)
                    
                # update list of known and detected requests
                self.known_events.add(event)
                self.known_event_ids.add(event.id)
                self.detected_events.add(event)

                # update list of event requesters
                self.event_requesters[event] = self.parent_name               

        # return list of generated requests
        return requests    

    @abstractmethod
    def process_observation(self, 
                            instrument : Instrument,
                            **kwargs
                            ) -> tuple:
        """ Processes incoming observation data and returns the characteristics of the event being detected if this exists """

    
class LookupProcessor(ObservationDataProcessor):
    def __init__(self, events_path : str, parent_name : str, mission : Mission):
        """ 
        ## Lookuup Table Science Module

        Has prior knowledge of all of the events that will occur during the simulation.
        Compares incoming observations to a predefined list of events to determine whether an event has been observed.
        """
        super().__init__(parent_name, mission)

        # load predefined events
        self.events_lookup : list[GeophysicalEvent] = self.load_events(events_path)

        # extract event-driven objectives from parent mission
        self.event_driven_objectives : Dict[str, set[EventDrivenObjective]] = defaultdict(set)
        for objective in self.parent_mission.objectives:
            if isinstance(objective, EventDrivenObjective):
                self.event_driven_objectives[objective.event_type].add(objective)

        # # extract detectable event types from mission objectives
        # self.detectable_event_types = defaultdict(set)
        # for objective in event_driven_objectives:
        #     self.detectable_event_types[objective.event_type].update(objective.valid_instruments)

        # # extract detectable event types from mission objectives
        # self.detectable_event_types = {objective.event_type : set()
        #                                for objective in self.parent_mission.objectives
        #                                if isinstance(objective, EventDrivenObjective)}
        # for objective in self.parent_mission.objectives:
        #     self.detectable_event_types[objective.event_type].update(objective.valid_instruments)

        # initialize update timer
        self.t_update = None

    def load_events(self, events_path : str) -> pd.DataFrame:

        if not os.path.isfile(events_path):
            raise ValueError('`events_path` must point to an existing file.')
        
        events_df : pd.DataFrame = pd.read_csv(events_path)

        events = []
        for _,row in events_df.iterrows():
            # convert event to GeophysicalEvent
            # event = GeophysicalEvent(
            #     row['event type'],
            #     (row['lat [deg]'], row['lon [deg]'], row.get('grid index', 0), row['gp_index']),
            #     row['start time [s]'],
            #     row['duration [s]'],
            #     row['severity'],
            #     row['start time [s]'],
            #     row['id']
            # )
            event = GeophysicalEvent(
                event_type=row['event type'],
                location=(row['lat [deg]'], row['lon [deg]'], row.get('grid index', 0), row['gp_index']),
                t_detect=row['start time [s]'],
                d_exp=row['duration [s]'],
                t_start=row['start time [s]'],
                severity=row['severity'],
                id=row['id']
            )
            events.append(event)

        return events
    
    def process_observation(self, 
                            instrument : str,
                            obs : dict
                            ) -> tuple:
        
        t_img_start = obs['t_start']
        t_img_end = obs['t_end']
        lat = obs['lat [deg]']
        lon = obs['lon [deg]']
        
        # update list of events to ignore expired events
        if self.t_update is None or abs(self.t_update - t_img_start) > 100.0:
            self.events_lookup = [event for event in self.events_lookup if event.is_active(t_img_start) or event.is_future(t_img_start)]
            self.t_update = t_img_start

        observed_events : List[GeophysicalEvent] = [ event.copy()
                                                    for event in self.events_lookup
                                                    # same location as the observation
                                                    if abs(lat - event.location[0]) <= 1e-3
                                                    and abs(lon - event.location[1]) <= 1e-3
                                                    # availability during the time of observation
                                                    and (event.t_start <= t_img_start <= event.t_start + event.d_exp
                                                        or event.t_start <= t_img_end <= event.t_start + event.d_exp)
                                                    # event has not been detected before
                                                    and (event.location[0],event.location[1],event.t_start,event.d_exp,event.severity,event.event_type) not in self.detected_events 
                                                    # event type is detectable by mission
                                                    and event.event_type in self.event_driven_objectives
                                                    # and instrument.lower() in self.detectable_event_types[event.event_type]
                                                    ]
        
        # modify event detection time to the end of the image
        for event in observed_events:
            event.t_detect = t_img_end

            # # calculate new start time
            # t_start = max(event.t_start, t_img_end)

            # # adjust start time and duration
            # assert t_start >= event.t_start, "Adjusted start time must be after original start time"
            # event.d_exp -= t_start-event.t_start
            # event.t_start = t_start
        
        # return highest severity event            
        return max(observed_events, key=lambda a: a.severity) if observed_events else None
